import 'package:flutter/material.dart';
import 'dart:typed_data';
import '../data/models/invoice_model.dart';
// import '../services/invoice_service.dart'; // Temporarily disabled

// Stub class for disabled service
class InvoiceService {
  Future<void> sendInvoiceByEmail(InvoiceModel invoice) async {}
  Future<void> sendPaymentReminder(InvoiceModel invoice) async {}
  Future<Uint8List> generatePdfBytes(InvoiceModel invoice) async => Uint8List(0);
  Future<void> savePdfToDevice(InvoiceModel invoice, Uint8List bytes) async {}
  Future<List<InvoiceModel>> getInvoices(String userId) async => [];
  Future<List<InvoiceModel>> getInvoicesByStatus(String userId, String status) async => [];
  Future<InvoiceModel?> getInvoice(String invoiceId) async => null;
  Future<String> createInvoice(InvoiceModel invoice) async => '';
  Future<void> updateInvoice(InvoiceModel invoice) async {}
  Future<void> updateInvoiceStatus(String invoiceId, String status) async {}
  Future<void> markAsPaid(String invoiceId, DateTime paidDate) async {}
  Future<void> deleteInvoice(String invoiceId) async {}
  Future<List<InvoiceModel>> getPendingInvoices(String userId) async => [];
  Stream<List<InvoiceModel>> streamInvoices(String userId) async* {
    yield [];
  }
}

/// Extended InvoiceProvider with Email Integration
/// 
/// This is an optional extension to InvoiceProvider that adds email capabilities.
/// Can be mixed into existing InvoiceProvider or used as a separate provider.
/// 
/// Usage:
/// ```dart
/// final invoiceProvider = InvoiceProvider();
/// 
/// // Send invoice via email
/// await invoiceProvider.sendInvoiceEmail(invoice);
/// 
/// // Send payment reminder
/// await invoiceProvider.sendPaymentReminder(invoice);
/// 
/// // Check loading state
/// if (invoiceProvider.isSendingEmail) {
///   print('Email is being sent...');
/// }
/// 
/// // Check for errors
/// if (invoiceProvider.emailError != null) {
///   print('Error: ${invoiceProvider.emailError}');
/// }
/// ```
mixin InvoiceEmailMixin on ChangeNotifier {
  InvoiceService? _service;
  
  bool _isSendingEmail = false;
  String? _emailError;

  bool get isSendingEmail => _isSendingEmail;
  String? get emailError => _emailError;

  InvoiceService get service {
    if (_service == null) {
      throw Exception('InvoiceService not initialized');
    }
    return _service!;
  }

  void initializeEmailService(InvoiceService service) {
    _service = service;
  }

  /// Send invoice via email to client
  /// 
  /// Sends a professional HTML email with invoice details.
  /// Auto-updates invoice status to 'sent' on success.
  /// 
  /// Parameters:
  /// - invoice: The invoice to send
  /// - includePdf: Whether to attach PDF (default: true)
  /// - customMessage: Custom email body (optional)
  /// 
  /// Returns: true if successful
  Future<bool> sendInvoiceEmail(
    InvoiceModel invoice, {
    bool includePdf = true,
    String? customMessage,
  }) async {
    _isSendingEmail = true;
    _emailError = null;
    notifyListeners();

    try {
      await service.sendInvoiceByEmail(
        invoice,
        attachPdf: includePdf,
        customMessage: customMessage,
      );
      
      _isSendingEmail = false;
      notifyListeners();
      return true;
    } catch (e) {
      _emailError = e.toString();
      _isSendingEmail = false;
      notifyListeners();
      return false;
    }
  }

  /// Send payment reminder for unpaid invoice
  /// 
  /// Sends a friendly payment reminder email.
  /// Only works for unpaid invoices.
  /// 
  /// Parameters:
  /// - invoice: The invoice to send reminder for
  /// 
  /// Returns: true if successful
  Future<bool> sendPaymentReminder(InvoiceModel invoice) async {
    if (invoice.status.toLowerCase() == 'paid') {
      _emailError = 'Cannot send reminder for already-paid invoice';
      notifyListeners();
      return false;
    }

    _isSendingEmail = true;
    _emailError = null;
    notifyListeners();

    try {
      await service.sendPaymentReminder(invoice);
      
      _isSendingEmail = false;
      notifyListeners();
      return true;
    } catch (e) {
      _emailError = e.toString();
      _isSendingEmail = false;
      notifyListeners();
      return false;
    }
  }

  /// Generate PDF bytes for invoice
  /// 
  /// Creates a professional PDF document.
  /// Useful for sharing, printing, or uploading.
  /// 
  /// Parameters:
  /// - invoice: The invoice to generate PDF for
  /// 
  /// Returns: PDF file as bytes
  Future<Uint8List?> generateInvoicePdf(InvoiceModel invoice) async {
    try {
      final pdfBytes = await service.generatePdfBytes(invoice);
      _emailError = null;
      notifyListeners();
      return pdfBytes;
    } catch (e) {
      _emailError = e.toString();
      notifyListeners();
      return null;
    }
  }

  /// Save PDF to device storage
  /// 
  /// Saves invoice PDF to Documents/invoices/ folder.
  /// 
  /// Parameters:
  /// - invoice: The invoice to save
  /// 
  /// Returns: Success message with file path
  Future<String?> savePdfToDevice(InvoiceModel invoice) async {
    try {
      final path = await service.savePdfToDevice(invoice);
      _emailError = null;
      notifyListeners();
      return path;
    } catch (e) {
      _emailError = e.toString();
      notifyListeners();
      return null;
    }
  }

  /// Clear email error state
  void clearEmailError() {
    _emailError = null;
    notifyListeners();
  }
}

/// Extended InvoiceProvider with Email Integration
/// 
/// Combines all invoice functionality with email sending capabilities.
/// 
/// Example usage in MultiProvider:
/// ```dart
/// MultiProvider(
///   providers: [
///     ChangeNotifierProvider(
///       create: (_) => InvoiceProviderWithEmail(),
///     ),
///   ],
///   child: MyApp(),
/// )
/// ```
class InvoiceProviderWithEmail extends ChangeNotifier with InvoiceEmailMixin {
  final InvoiceService _service;
  
  List<InvoiceModel> _invoices = [];
  InvoiceModel? _selectedInvoice;
  bool _isLoading = false;
  String? _error;

  InvoiceProviderWithEmail({InvoiceService? service})
      : _service = service ?? InvoiceService() {
    initializeEmailService(_service);
  }

  List<InvoiceModel> get invoices => _invoices;
  InvoiceModel? get selectedInvoice => _selectedInvoice;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasInvoices => _invoices.isNotEmpty;

  void _setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }

  void _setError(String? error) {
    _error = error;
    notifyListeners();
  }

  /// Load all invoices
  Future<void> loadInvoices() async {
    _setLoading(true);
    try {
      _invoices = await _service.getInvoices();
      _setError(null);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  /// Load invoices by status
  Future<void> loadInvoicesByStatus(String status) async {
    _setLoading(true);
    try {
      _invoices = await _service.getInvoicesByStatus(status);
      _setError(null);
    } catch (e) {
      _setError(e.toString());
    } finally {
      _setLoading(false);
    }
  }

  /// Get invoice by ID
  Future<void> getInvoice(String invoiceId) async {
    try {
      _selectedInvoice = await _service.getInvoice(invoiceId);
      _setError(null);
    } catch (e) {
      _setError(e.toString());
      _selectedInvoice = null;
    }
  }

  /// Create new invoice
  Future<bool> createInvoice({
    required String clientId,
    required String clientName,
    required String clientEmail,
    required List<InvoiceItem> items,
    required String currency,
    required double taxRate,
    String? invoiceNumber,
    DateTime? dueDate,
  }) async {
    _setLoading(true);
    try {
      final invoice = await _service.createInvoice(
        clientId: clientId,
        clientName: clientName,
        clientEmail: clientEmail,
        items: items,
        currency: currency,
        taxRate: taxRate,
        invoiceNumber: invoiceNumber,
        dueDate: dueDate,
      );

      _invoices.insert(0, invoice);
      _setError(null);
      _setLoading(false);
      return true;
    } catch (e) {
      _setError(e.toString());
      _setLoading(false);
      return false;
    }
  }

  /// Update invoice
  Future<bool> updateInvoice(InvoiceModel invoice) async {
    try {
      await _service.updateInvoice(invoice);

      final index = _invoices.indexWhere((i) => i.id == invoice.id);
      if (index >= 0) {
        _invoices[index] = invoice;
      }

      _setError(null);
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }

  /// Update invoice status
  Future<bool> updateStatus(String invoiceId, String newStatus) async {
    try {
      await _service.updateInvoiceStatus(invoiceId, newStatus);

      final index = _invoices.indexWhere((i) => i.id == invoiceId);
      if (index >= 0) {
        _invoices[index] =
            _invoices[index].copyWith(status: newStatus);
      }

      _setError(null);
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }

  /// Mark invoice as paid
  Future<bool> markAsPaid(String invoiceId) async {
    try {
      await _service.markAsPaid(invoiceId);

      final index = _invoices.indexWhere((i) => i.id == invoiceId);
      if (index >= 0) {
        _invoices[index] = _invoices[index].copyWith(
          status: 'paid',
          paidDate: DateTime.now(),
        );
      }

      _setError(null);
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }

  /// Delete invoice
  Future<bool> deleteInvoice(String invoiceId) async {
    try {
      await _service.deleteInvoice(invoiceId);
      _invoices.removeWhere((i) => i.id == invoiceId);
      _setError(null);
      return true;
    } catch (e) {
      _setError(e.toString());
      return false;
    }
  }

  /// Get pending invoices
  Future<List<InvoiceModel>> getPendingInvoices() async {
    try {
      return await _service.getPendingInvoices();
    } catch (e) {
      _setError(e.toString());
      return [];
    }
  }

  /// Watch invoices stream
  Stream<List<InvoiceModel>> watchInvoices() {
    return _service.streamInvoices();
  }

  /// Clear selection
  void clearSelection() {
    _selectedInvoice = null;
    notifyListeners();
  }

  /// Clear error
  void clearError() {
    _setError(null);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// USAGE EXAMPLES
// ═══════════════════════════════════════════════════════════════════════════════

/// Example 1: Using InvoiceProviderWithEmail in MultiProvider
/// 
/// In your main.dart:
/// ```dart
/// void main() {
///   runApp(
///     MultiProvider(
///       providers: [
///         ChangeNotifierProvider(
///           create: (_) => InvoiceProviderWithEmail(),
///         ),
///       ],
///       child: MyApp(),
///     ),
///   );
/// }
/// ```

/// Example 2: Send invoice from widget
/// 
/// ```dart
/// Consumer<InvoiceProviderWithEmail>(
///   builder: (context, provider, _) {
///     return ElevatedButton(
///       onPressed: () async {
///         final success = await provider.sendInvoiceEmail(invoice);
///         if (success) {
///           ScaffoldMessenger.of(context).showSnackBar(
///             SnackBar(content: Text('Invoice sent!')),
///           );
///         } else {
///           ScaffoldMessenger.of(context).showSnackBar(
///             SnackBar(
///               content: Text('Error: ${provider.emailError}'),
///               backgroundColor: Colors.red,
///             ),
///           );
///         }
///       },
///       child: Text(
///         provider.isSendingEmail ? 'Sending...' : 'Send Invoice',
///       ),
///     );
///   },
/// )
/// ```

/// Example 3: Reminder button with state management
/// 
/// ```dart
/// Consumer<InvoiceProviderWithEmail>(
///   builder: (context, provider, _) {
///     final isPaid = invoice.status.toLowerCase() == 'paid';
///     
///     return ElevatedButton(
///       onPressed: isPaid || provider.isSendingEmail
///           ? null
///           : () async {
///               final success = await provider.sendPaymentReminder(invoice);
///               if (success) {
///                 ScaffoldMessenger.of(context).showSnackBar(
///                   SnackBar(content: Text('Reminder sent!')),
///                 );
///               }
///             },
///       child: Text(
///         provider.isSendingEmail ? 'Sending...' : 'Send Reminder',
///       ),
///     );
///   },
/// )
/// ```

/// Example 4: Combined CRUD + Email in detail screen
/// 
/// ```dart
/// Consumer<InvoiceProviderWithEmail>(
///   builder: (context, provider, _) {
///     final invoice = provider.selectedInvoice;
///     if (invoice == null) return SizedBox.shrink();
///     
///     return Column(
///       children: [
///         // Invoice details
///         Card(
///           child: Padding(
///             padding: EdgeInsets.all(16),
///             child: Column(
///               crossAxisAlignment: CrossAxisAlignment.start,
///               children: [
///                 Text('Invoice ${invoice.invoiceNumber}'),
///                 Text('Total: ${invoice.currency} ${invoice.total}'),
///               ],
///             ),
///           ),
///         ),
///         SizedBox(height: 16),
///         // Action buttons
///         Row(
///           children: [
///             ElevatedButton(
///               onPressed: provider.isSendingEmail
///                   ? null
///                   : () => provider.sendInvoiceEmail(invoice),
///               child: Text('Send'),
///             ),
///             SizedBox(width: 8),
///             ElevatedButton(
///               onPressed: provider.isLoading
///                   ? null
///                   : () => provider.markAsPaid(invoice.id),
///               child: Text('Mark Paid'),
///             ),
///           ],
///         ),
///         if (provider.emailError != null) ...[
///           SizedBox(height: 16),
///           Container(
///             padding: EdgeInsets.all(12),
///             decoration: BoxDecoration(
///               color: Colors.red.shade100,
///               borderRadius: BorderRadius.circular(4),
///             ),
///             child: Text(
///               'Error: ${provider.emailError}',
///               style: TextStyle(color: Colors.red.shade900),
///             ),
///           ),
///         ],
///       ],
///     );
///   },
/// )
/// ```

