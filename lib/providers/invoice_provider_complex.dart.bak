import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../data/models/invoice_model.dart';
// import '../services/invoice_service.dart'; // Temporarily disabled
import '../services/firebase/storage_service.dart';
import '../utils/extensions.dart';

class InvoiceProvider extends ChangeNotifier {
  // final InvoiceService _service; // Temporarily disabled
  final StorageService _storage = StorageService();
  
  List<InvoiceModel> _invoices = [];
  InvoiceModel? _selectedInvoice;
  InvoiceModel? _editingInvoice;
  bool _isLoading = false;
  String? _error;

  InvoiceProvider() {
    // Initialize
  }

  List<InvoiceModel> get invoices => _invoices;
  InvoiceModel? get selectedInvoice => _selectedInvoice;
  InvoiceModel? get editingInvoice => _editingInvoice;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasInvoices => _invoices.isNotEmpty;

  /// Listen to user's invoices
  void listenToInvoices(String userId) {
    // TODO: Implement real-time listener
    _invoices = [];
    notifyListeners();
  }

  // ═══════════════════════════════════════════════════════════════
  // INVOICE EDITING (Form/Draft Mode)
  // ═══════════════════════════════════════════════════════════════

  /// Start editing a new blank invoice
  void startNewInvoice(String userId, {String? clientId, String? clientName, String? clientEmail}) {
    _editingInvoice = InvoiceModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      userId: userId,
      clientId: clientId ?? '',
      clientName: clientName ?? '',
      clientEmail: clientEmail ?? '',
      items: [],
      subtotal: 0.0,
      tax: 0.0,
      total: 0.0,
      currency: 'USD',
      taxRate: 0.0,
      status: 'draft',
      createdAt: Timestamp.now(),
    );
    _error = null;
    notifyListeners();
  }

  /// Load existing invoice for editing
  void startEditingInvoice(InvoiceModel invoice) {
    _editingInvoice = invoice;
    _error = null;
    notifyListeners();
  }

  /// Set client details for editing invoice
  void setEditingClient({required String id, required String name, required String email}) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(
      clientId: id,
      clientName: name,
      clientEmail: email,
    );
    notifyListeners();
  }

  /// Add item to editing invoice
  void addItemToEditing(InvoiceItem item) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(
      items: [..._editingInvoice!.items, item],
    );
    _recalculateEditing();
  }

  /// Update item in editing invoice
  void updateItemInEditing(int index, InvoiceItem item) {
    if (_editingInvoice == null || index >= _editingInvoice!.items.length) return;
    final items = [..._editingInvoice!.items];
    items[index] = item;
    _editingInvoice = _editingInvoice!.copyWith(items: items);
    _recalculateEditing();
  }

  /// Remove item from editing invoice
  void removeItemFromEditing(int index) {
    if (_editingInvoice == null || index >= _editingInvoice!.items.length) return;
    final items = [..._editingInvoice!.items];
    items.removeAt(index);
    _editingInvoice = _editingInvoice!.copyWith(items: items);
    _recalculateEditing();
  }

  /// Set tax rate and recalculate
  void setEditingTaxRate(double rate) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(taxRate: rate);
    _recalculateEditing();
  }

  /// Set currency
  void setEditingCurrency(String currency) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(currency: currency);
    notifyListeners();
  }

  /// Set due date
  void setEditingDueDate(DateTime dueDate) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(dueDate: dueDate);
    notifyListeners();
  }

  /// Set invoice number
  void setEditingInvoiceNumber(String number) {
    if (_editingInvoice == null) return;
    _editingInvoice = _editingInvoice!.copyWith(invoiceNumber: number);
    notifyListeners();
  }

  /// Recalculate totals for editing invoice
  void _recalculateEditing() {
    if (_editingInvoice == null) return;
    double subtotal = 0.0;
    for (var item in _editingInvoice!.items) {
      subtotal += item.total;
    }
    final taxAmount = subtotal * _editingInvoice!.taxRate;
    final total = subtotal + taxAmount;
    
    _editingInvoice = _editingInvoice!.copyWith(
      subtotal: subtotal,
      tax: taxAmount,
      total: total,
    );
    notifyListeners();
  }

  /// Save and send editing invoice
  /// - Saves to Firestore
  /// - Optionally uploads PDF to Firebase Storage
  /// - Optionally sends email to client
  Future<bool> saveAndSendEditingInvoice({
    bool sendEmail = true,
    bool uploadPdf = true,
  }) async {
    if (_editingInvoice == null) {
      _error = 'No invoice being edited';
      notifyListeners();
      return false;
    }

    _setLoading(true);
    try {
      // Save invoice to Firestore
      await _service.updateInvoice(_editingInvoice!);

      // Upload PDF to Firebase Storage if requested
      if (uploadPdf) {
        final bytes = await _service.generatePdfBytes(_editingInvoice!);
        final pdfUrl = await _storage.uploadInvoicePdf(
          _editingInvoice!.userId,
          _editingInvoice!.id,
          bytes,
        );
        
        // Update invoice with PDF URL
        _editingInvoice = _editingInvoice!.copyWith(
          pdfUrl: pdfUrl,
        );
        await _service.updateInvoice(_editingInvoice!);
      }

      // Send email if requested
      if (sendEmail) {
        await _service.sendInvoiceByEmail(_editingInvoice!);
      }

      // Update in list
      final index = _invoices.indexWhere((inv) => inv.id == _editingInvoice!.id);
      if (index >= 0) {
        _invoices[index] = _editingInvoice!;
      }

      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = e.toString();
      _setLoading(false);
      return false;
    }
  }

  /// Discard editing invoice
  void cancelEditingInvoice() {
    _editingInvoice = null;
    _error = null;
    notifyListeners();
  }

  // ═══════════════════════════════════════════════════════════════
  // INVOICE LIST OPERATIONS
  // ═══════════════════════════════════════════════════════════════

  /// Load all invoices
  Future<void> loadInvoices() async {
    _setLoading(true);
    try {
      _invoices = await _service.getInvoices();
      _error = null;
    } catch (e) {
      _error = e.toString();
    } finally {
      _setLoading(false);
    }
  }

  /// Load invoices by status
  Future<void> loadInvoicesByStatus(String status) async {
    _setLoading(true);
    try {
      _invoices = await _service.getInvoicesByStatus(status);
      _error = null;
    } catch (e) {
      _error = e.toString();
    } finally {
      _setLoading(false);
    }
  }

  /// Get invoice by ID
  Future<void> getInvoice(String invoiceId) async {
    try {
      _selectedInvoice = await _service.getInvoice(invoiceId);
      _error = null;
    } catch (e) {
      _error = e.toString();
      _selectedInvoice = null;
    }
    notifyListeners();
  }

  /// Create new invoice
  Future<bool> createInvoice({
    required String clientId,
    required String clientName,
    required String clientEmail,
    required List<InvoiceItem> items,
    required String currency,
    required double taxRate,
    String? invoiceNumber,
    DateTime? dueDate,
  }) async {
    _setLoading(true);
    try {
      final invoice = await _service.createInvoice(
        clientId: clientId,
        clientName: clientName,
        clientEmail: clientEmail,
        items: items,
        currency: currency,
        taxRate: taxRate,
        invoiceNumber: invoiceNumber,
        dueDate: dueDate,
      );
      _invoices.insert(0, invoice);
      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = e.toString();
      _setLoading(false);
      return false;
    }
  }

  /// Update invoice
  Future<bool> updateInvoice(InvoiceModel invoice) async {
    try {
      await _service.updateInvoice(invoice);
      final index = _invoices.indexWhere((inv) => inv.id == invoice.id);
      if (index >= 0) {
        _invoices[index] = invoice;
      }
      _error = null;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Update invoice status
  Future<bool> updateStatus(String invoiceId, String newStatus) async {
    try {
      await _service.updateInvoiceStatus(invoiceId, newStatus);
      final index = _invoices.indexWhere((inv) => inv.id == invoiceId);
      if (index >= 0) {
        _invoices[index] = _invoices[index].copyWith(status: newStatus);
      }
      _error = null;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Mark as paid
  Future<bool> markAsPaid(String invoiceId) async {
    return updateStatus(invoiceId, 'paid');
  }

  /// Mark invoice as paid with Stripe payment details
  /// Called after successful webhook validation
  Future<bool> markInvoiceAsPaid(
    String invoiceId,
    double paidAmount,
    String paidCurrency,
    String paymentIntentId,
  ) async {
    try {
      final index = _invoices.indexWhere((inv) => inv.id == invoiceId);
      if (index < 0) {
        _error = 'Invoice not found';
        notifyListeners();
        return false;
      }

      final invoice = _invoices[index];
      final updatedInvoice = invoice.copyWith(
        status: 'paid',
        paidDate: DateTime.now(),
      );

      await _service.updateInvoice(updatedInvoice);
      _invoices[index] = updatedInvoice;
      _error = null;
      notifyListeners();
      return true;
    } catch (e) {
      _error = 'Failed to mark invoice as paid: ${e.toString()}';
      notifyListeners();
      return false;
    }
  }

  /// Get payment errors for an invoice (validation failures)
  Future<List<Map<String, dynamic>>> getPaymentErrors(String invoiceId) async {
    try {
      // Payment errors - return empty for now
      return [];
    } catch (e) {
      _error = 'Failed to fetch payment errors: ${e.toString()}';
      notifyListeners();
      return [];
    }
  }

  /// Get payment records for an invoice
  Future<List<Map<String, dynamic>>> getPayments(String invoiceId) async {
    try {
      // Payment records - return empty for now
      return [];
    } catch (e) {
      _error = 'Failed to fetch payment records: ${e.toString()}';
      notifyListeners();
      return [];
    }
  }

  /// Delete invoice
  Future<bool> deleteInvoice(String invoiceId) async {
    try {
      await _service.deleteInvoice(invoiceId);
      _invoices.removeWhere((inv) => inv.id == invoiceId);
      _error = null;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Get invoice count
  Future<int> getInvoiceCount(String status) async {
    try {
      return await _service.getInvoiceCount(status);
    } catch (e) {
      return 0;
    }
  }

  /// Get total revenue
  Future<double> getTotalRevenue() async {
    try {
      return await _service.getTotalRevenue();
    } catch (e) {
      return 0;
    }
  }

  /// Get pending invoices
  Future<void> loadPendingInvoices() async {
    _setLoading(true);
    try {
      _invoices = await _service.getPendingInvoices();
      _error = null;
    } catch (e) {
      _error = e.toString();
    } finally {
      _setLoading(false);
    }
  }

  /// Stream invoices
  Stream<List<InvoiceModel>> watchInvoices() {
    return _service.streamInvoices();
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 1: BULK OPERATIONS
  // ═══════════════════════════════════════════════════════════════

  /// Mark multiple invoices as paid
  Future<bool> markMultipleAsPaid(List<String> invoiceIds) async {
    _setLoading(true);
    try {
      for (final id in invoiceIds) {
        await updateStatus(id, 'paid');
      }
      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = 'Failed to mark invoices as paid: $e';
      _setLoading(false);
      return false;
    }
  }

  /// Delete multiple invoices
  Future<bool> deleteMultiple(List<String> invoiceIds) async {
    _setLoading(true);
    try {
      for (final id in invoiceIds) {
        await deleteInvoice(id);
      }
      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = 'Failed to delete invoices: $e';
      _setLoading(false);
      return false;
    }
  }

  /// Duplicate invoice (create a copy with cleared amounts)
  Future<bool> duplicateInvoice(String invoiceId) async {
    _setLoading(true);
    try {
      final original = _invoices.firstWhere((inv) => inv.id == invoiceId);
      final duplicate = InvoiceModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        userId: original.userId,
        clientId: original.clientId,
        clientName: original.clientName,
        clientEmail: original.clientEmail,
        items: original.items,
        subtotal: original.subtotal,
        tax: original.tax,
        total: original.total,
        currency: original.currency,
        taxRate: original.taxRate,
        status: 'draft',
        createdAt: Timestamp.now(),
        invoiceNumber: original.invoiceNumber != null
            ? '${original.invoiceNumber}-COPY'
            : null,
        dueDate: original.dueDate,
      );
      
      await _service.createInvoiceWithModel(duplicate);
      _invoices.insert(0, duplicate);
      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = 'Failed to duplicate invoice: $e';
      _setLoading(false);
      return false;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 2: FILTERING & SEARCH
  // ═══════════════════════════════════════════════════════════════

  /// Search invoices by client name or invoice number
  List<InvoiceModel> searchInvoices(String query) {
    final lowerQuery = query.toLowerCase();
    return _invoices.where((inv) {
      return inv.clientName.toLowerCase().contains(lowerQuery) ||
             (inv.invoiceNumber?.toLowerCase().contains(lowerQuery) ?? false);
    }).toList();
  }

  /// Get invoices by date range
  Future<List<InvoiceModel>> getInvoicesByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final filtered = _invoices.where((inv) {
        final invDate = inv.createdAt.toDate();
        return invDate.isAfter(startDate) && invDate.isBefore(endDate);
      }).toList();
      return filtered;
    } catch (e) {
      _error = 'Failed to filter by date: $e';
      notifyListeners();
      return [];
    }
  }

  /// Get overdue invoices
  Future<List<InvoiceModel>> getOverdueInvoices() async {
    try {
      final now = DateTime.now();
      final overdue = _invoices.where((inv) {
        if (inv.status == 'paid') return false;
        if (inv.dueDate == null) return false;
        return inv.dueDate!.isBefore(now);
      }).toList();
      return overdue;
    } catch (e) {
      _error = 'Failed to get overdue invoices: $e';
      notifyListeners();
      return [];
    }
  }

  /// Load overdue invoices
  Future<void> loadOverdueInvoices() async {
    _setLoading(true);
    try {
      _invoices = await getOverdueInvoices();
      _error = null;
    } catch (e) {
      _error = e.toString();
    } finally {
      _setLoading(false);
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 3: STATISTICS & ANALYTICS
  // ═══════════════════════════════════════════════════════════════

  /// Get total revenue from all paid invoices
  Future<double> getPaidRevenue() async {
    try {
      final total = _invoices
          .where((inv) => inv.status == 'paid')
          .fold<double>(0.0, (sum, inv) => sum + inv.total);
      return total;
    } catch (e) {
      return 0.0;
    }
  }

  /// Get pending (unpaid) revenue
  Future<double> getPendingRevenue() async {
    try {
      final total = _invoices
          .where((inv) => inv.status != 'paid' && inv.status != 'draft')
          .fold<double>(0.0, (sum, inv) => sum + inv.total);
      return total;
    } catch (e) {
      return 0.0;
    }
  }

  /// Get average invoice amount
  Future<double> getAverageInvoiceAmount() async {
    try {
      if (_invoices.isEmpty) return 0.0;
      final total = _invoices.fold(0.0, (sum, inv) => sum + inv.total);
      return total / _invoices.length;
    } catch (e) {
      return 0.0;
    }
  }

  /// Get monthly revenue breakdown
  Future<Map<String, double>> getMonthlyRevenue() async {
    try {
      final monthly = <String, double>{};
      
      for (final invoice in _invoices) {
        if (invoice.status != 'paid') continue;
        
        final date = invoice.createdAt.toDate();
        final monthKey = '${date.year}-${date.month.toString().padLeft(2, '0')}';
        
        monthly[monthKey] = (monthly[monthKey] ?? 0) + invoice.total;
      }
      
      return monthly;
    } catch (e) {
      return {};
    }
  }

  /// Get invoice statistics
  Future<Map<String, dynamic>> getInvoiceStats() async {
    try {
      final totalRevenue = await getTotalRevenue();
      final paidRevenue = await getPaidRevenue();
      final pendingRevenue = await getPendingRevenue();
      final averageAmount = await getAverageInvoiceAmount();
      final totalCount = _invoices.length;
      final paidCount = _invoices.where((inv) => inv.status == 'paid').length;
      final draftCount = _invoices.where((inv) => inv.status == 'draft').length;
      final sentCount = _invoices.where((inv) => inv.status == 'sent').length;
      final overdueCount = (await getOverdueInvoices()).length;
      
      return {
        'totalRevenue': totalRevenue,
        'paidRevenue': paidRevenue,
        'pendingRevenue': pendingRevenue,
        'averageAmount': averageAmount,
        'totalInvoices': totalCount,
        'paidInvoices': paidCount,
        'draftInvoices': draftCount,
        'sentInvoices': sentCount,
        'overdueInvoices': overdueCount,
      };
    } catch (e) {
      return {};
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 4: EXPORT & SHARING
  // ═══════════════════════════════════════════════════════════════

  /// Export all invoices to CSV
  Future<String?> exportToCSV() async {
    try {
      final buffer = StringBuffer();
      
      // Header
      buffer.writeln(
        'Invoice Number,Client Name,Amount,Tax,Total,Currency,Status,Created Date,Due Date'
      );
      
      // Data rows
      for (final invoice in _invoices) {
        final createdDate = invoice.createdAt.toDate().toString().split(' ')[0];
        final dueDate = invoice.dueDate?.toString().split(' ')[0] ?? 'N/A';
        
        buffer.writeln(
          '${invoice.invoiceNumber ?? 'N/A'},'
          '${invoice.clientName},'
          '${invoice.subtotal},'
          '${invoice.tax},'
          '${invoice.total},'
          '${invoice.currency},'
          '${invoice.status},'
          '$createdDate,'
          '$dueDate'
        );
      }
      
      return buffer.toString();
    } catch (e) {
      _error = 'Failed to export CSV: $e';
      notifyListeners();
      return null;
    }
  }

  /// Export filtered invoices to CSV
  Future<String?> exportFilteredToCSV(String status) async {
    try {
      final filtered = _invoices.where((inv) => inv.status == status).toList();
      final buffer = StringBuffer();
      
      buffer.writeln(
        'Invoice Number,Client Name,Amount,Tax,Total,Currency,Status,Created Date,Due Date'
      );
      
      for (final invoice in filtered) {
        final createdDate = invoice.createdAt.toDate().toString().split(' ')[0];
        final dueDate = invoice.dueDate?.toString().split(' ')[0] ?? 'N/A';
        
        buffer.writeln(
          '${invoice.invoiceNumber ?? 'N/A'},'
          '${invoice.clientName},'
          '${invoice.subtotal},'
          '${invoice.tax},'
          '${invoice.total},'
          '${invoice.currency},'
          '${invoice.status},'
          '$createdDate,'
          '$dueDate'
        );
      }
      
      return buffer.toString();
    } catch (e) {
      _error = 'Failed to export filtered CSV: $e';
      notifyListeners();
      return null;
    }
  }

  /// Get shareable invoice data (JSON)
  Map<String, dynamic>? getInvoiceShareData(String invoiceId) {
    try {
      final invoice = _invoices.firstWhere((inv) => inv.id == invoiceId);
      return invoice.toJson();
    } catch (e) {
      _error = 'Invoice not found: $e';
      notifyListeners();
      return null;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 5: TEMPLATES
  // ═══════════════════════════════════════════════════════════════

  List<InvoiceModel> _templates = [];

  List<InvoiceModel> get templates => _templates;

  /// Save invoice as template
  void saveAsTemplate(String invoiceId, String templateName) {
    try {
      final invoice = _invoices.firstWhere((inv) => inv.id == invoiceId);
      final template = invoice.copyWith(
        id: 'template_${DateTime.now().millisecondsSinceEpoch}',
        status: 'template',
      );
      _templates.add(template);
      notifyListeners();
    } catch (e) {
      _error = 'Failed to save template: $e';
      notifyListeners();
    }
  }

  /// Get all templates
  List<InvoiceModel> getTemplates() {
    return _templates;
  }

  /// Create invoice from template
  Future<bool> createFromTemplate(String templateId, String clientId, String clientName, String clientEmail) async {
    _setLoading(true);
    try {
      final template = _templates.firstWhere((t) => t.id == templateId);
      final newInvoice = InvoiceModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        userId: template.userId,
        clientId: clientId,
        clientName: clientName,
        clientEmail: clientEmail,
        items: template.items,
        subtotal: template.subtotal,
        tax: template.tax,
        total: template.total,
        currency: template.currency,
        taxRate: template.taxRate,
        status: 'draft',
        createdAt: Timestamp.now(),
        dueDate: DateTime.now().add(const Duration(days: 30)),
      );
      
      await _service.createInvoiceWithModel(newInvoice);
      _invoices.insert(0, newInvoice);
      _error = null;
      _setLoading(false);
      return true;
    } catch (e) {
      _error = 'Failed to create from template: $e';
      _setLoading(false);
      return false;
    }
  }

  /// Delete template
  void deleteTemplate(String templateId) {
    _templates.removeWhere((t) => t.id == templateId);
    notifyListeners();
  }

  // ═══════════════════════════════════════════════════════════════
  // FEATURE 6: REMINDERS
  // ═══════════════════════════════════════════════════════════════

  final Map<String, DateTime> _reminderDates = {};

  Map<String, DateTime> get reminderDates => _reminderDates;

  /// Set payment reminder for invoice
  void setReminderDate(String invoiceId, DateTime reminderDate) {
    _reminderDates[invoiceId] = reminderDate;
    notifyListeners();
  }

  /// Get upcoming reminders (due in next 7 days)
  Future<List<Map<String, dynamic>>> getUpcomingReminders() async {
    try {
      final now = DateTime.now();
      final weekFromNow = now.add(const Duration(days: 7));
      final reminders = <Map<String, dynamic>>[];
      
      for (final entry in _reminderDates.entries) {
        final invoiceId = entry.key;
        final reminderDate = entry.value;
        
        if (reminderDate.isAfter(now) && reminderDate.isBefore(weekFromNow)) {
          final invoice = _invoices.firstWhereOrNull((inv) => inv.id == invoiceId);
          if (invoice != null && invoice.status != 'paid') {
            reminders.add({
              'invoiceId': invoiceId,
              'invoiceNumber': invoice.invoiceNumber,
              'clientName': invoice.clientName,
              'amount': invoice.total,
              'dueDate': reminderDate,
              'daysUntilDue': reminderDate.difference(now).inDays,
            });
          }
        }
      }
      
      return reminders;
    } catch (e) {
      _error = 'Failed to get reminders: $e';
      notifyListeners();
      return [];
    }
  }

  /// Send payment reminder email
  Future<bool> sendPaymentReminder(String invoiceId) async {
    try {
      final invoice = _invoices.firstWhere((inv) => inv.id == invoiceId);
      
      // Send reminder email (assuming EmailService has this)
      await _service.sendInvoiceByEmail(invoice);
      
      return true;
    } catch (e) {
      _error = 'Failed to send reminder: $e';
      notifyListeners();
      return false;
    }
  }

  /// Get invoice reminder status
  bool hasReminder(String invoiceId) {
    return _reminderDates.containsKey(invoiceId);
  }

  /// Remove reminder
  void removeReminder(String invoiceId) {
    _reminderDates.remove(invoiceId);
    notifyListeners();
  }

  /// Clear error
  void clearError() {
    _error = null;
    notifyListeners();
  }

  void _setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }
}
