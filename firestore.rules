rules_version = '2';
service cloud.firestore {
  // ==================== HELPER FUNCTIONS ====================
  function isAdmin() {
    return request.auth != null && request.auth.token.admin == true;
  }

  // Get user role from token (set by onUserCreate Cloud Function)
  // Default: 'owner' for backward compatibility
  function getUserRole() {
    return request.auth.token.role != null ? request.auth.token.role : 'owner';
  }

  // Check if user is owner role
  function isOwner() {
    return getUserRole() == 'owner';
  }

  // Check if user is employee role
  function isEmployee() {
    return getUserRole() == 'employee';
  }

  // Check authentication
  function isAuthenticated() {
    return request.auth != null;
  }

  // Check if user owns resource
  function isResourceOwner(userId) {
    return request.auth.uid == userId;
  }

  // Validate data types for common fields
  function hasValidEmail(email) {
    return email is string && 
           email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
  }

  function hasValidPhone(phone) {
    return phone is string && phone.matches('^[+0-9 ()-]+$');
  }

  function hasValidAmount(amount) {
    return amount is number && amount > 0;
  }

  // Rate limiting check
  function isRateLimited(collection) {
    return request.time < resource.data.lastModified.toMillis() + 1000;
  }

  match /databases/{database}/documents {
    // Top-level user documents - ownership-based access control
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // user devices
    match /users/{uid}/devices/{deviceId} {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow create: if request.auth != null && request.auth.uid == uid;
      allow update: if request.auth != null && request.auth.uid == uid;
      allow delete: if request.auth != null && request.auth.uid == uid;
    }

    // user notifications - readable by owner
    match /users/{uid}/notifications/{notifId} {
      allow read: if request.auth != null && request.auth.uid == uid;
      // Clients should not create notifications - only server (admin) may
      allow create: if false;
      allow update: if request.auth != null && request.auth.uid == uid && request.resource.data.keys().hasOnly(['read']);
      allow delete: if request.auth != null && request.auth.uid == uid;
    }

    // user notification preferences - read/write by owner
    match /users/{uid}/settings/notification_preferences {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if request.auth != null && request.auth.uid == uid;
    }

    // user timezone & locale - read/write by owner
    match /users/{uid}/settings/timezone {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if request.auth != null && request.auth.uid == uid;
    }

    // notification audit (server writes only, users read their own, admins read all)
    match /notifications_audit/{docId} {
      allow read: if request.auth != null && (resource.data.targetUid == request.auth.uid || isAdmin());
      allow write: if false;
    }

    // analytics & other server-only collections should be blocked for client writes
    match /analytics/{document=**} {
      allow read: if request.auth != null && (request.auth.token.admin == true || request.auth.token.auraRole == 'analyst');
      allow write: if false;
    }

    // AuraToken wallet - users can read their own balance, server writes only
    match /users/{userId}/wallet/aura {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if false; // Server-only via Cloud Functions
    }

    // Token audit log - users can read their own transactions, immutable
    match /users/{userId}/token_audit/{auditId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create, update, delete: if false;
    }

    // Processed payment sessions - webhook only, no client access
    match /payments_processed/{sessionId} {
      allow read, write: if false; // Written only by webhook function
    }

    // User loyalty profile - readable by owner, server writes only
    match /users/{uid}/loyalty/{document=**} {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if false; // Only server (Cloud Functions) may modify
    }

    // Global loyalty configuration - publicly readable, server writes only
    match /loyalty_config/{document=**} {
      allow read: if true; // Public config for all users
      allow write: if false; // Only server (Cloud Functions) may modify
    }

    // Event rewards - publicly readable, admin writes only
    match /event_rewards/{document=**} {
      allow read: if true; // Public for all users
      allow write: if isAdmin(); // Admin only
    }

    // Loyalty campaigns - publicly readable, admin writes only
    match /loyalty_campaigns/{document=**} {
      allow read: if true; // Public for all users
      allow write: if isAdmin(); // Admin only
    }

    // Reward configuration - publicly readable, admin writes only
    match /reward_config/{document=**} {
      allow read: if true; // Public for all users
      allow write: if isAdmin(); // Admin only
    }

    // Admin panel collections
    match /admin/{doc=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Admin event logs
    match /admin_logs/{doc=**} {
      allow read: if isAdmin();
      allow write: if false; // Server-only writes
    }

    // ==================== ROLE-BASED ACCESS CONTROL ====================
    // Based on Feature Access Matrix implementation
    // Owners have full access, Employees have limited access

    // Clients - Owners full access, Employees read-only (assigned)
    match /users/{uid}/clients/{clientId} {
      allow read: if isResourceOwner(uid) && isOwner();
      allow read: if isResourceOwner(uid) && isEmployee() 
                   && resource.data.assignedTo == request.auth.uid;
      allow write: if isResourceOwner(uid) && isOwner()
                      && request.resource.data.name is string
                      && request.resource.data.name.size() > 0
                      && (request.resource.data.email == null || hasValidEmail(request.resource.data.email))
                      && (request.resource.data.phone == null || hasValidPhone(request.resource.data.phone));
    }

    match /clients/{clientId} {
      allow read: if (isOwner() || (isEmployee() && resource.data.assignedTo == request.auth.uid))
                      && resource.data.name is string;
      allow write: if isOwner()
                      && request.resource.data.name is string
                      && request.resource.data.name.size() > 0;
    }

    // Tasks - Owners full access, Employees can read/update assigned tasks only
    match /users/{uid}/tasks/{taskId} {
      allow read: if isResourceOwner(uid) && isOwner();
      allow read: if isResourceOwner(uid) && isEmployee() 
                   && resource.data.assignedTo == request.auth.uid;
      allow write: if isResourceOwner(uid) && isOwner();
      allow update: if isResourceOwner(uid) && isEmployee() 
                    && resource.data.assignedTo == request.auth.uid
                    && request.resource.data.keys().hasOnly(['status', 'completedAt', 'notes']);
    }

    match /tasks/{taskId} {
      allow read: if (isOwner() || (isEmployee() && resource.data.assignedTo == request.auth.uid))
                      && resource.data.title is string;
      allow write: if isOwner()
                      && request.resource.data.title is string
                      && request.resource.data.title.size() > 0;
      allow update: if isEmployee() && resource.data.assignedTo == request.auth.uid
                    && request.resource.data.keys().hasOnly(['status', 'completedAt', 'notes']);
    }

    // ==================== EXPENSES ====================
    // Expenses - Comprehensive validation with amount limits and field constraints
    // Server-side validation in Cloud Functions is REQUIRED (cannot bypass)
    match /expenses/{expenseId} {
      allow create: if isAuthenticated() 
                      && request.resource.data.userId == request.auth.uid
                      // Amount validation: $0.01 - $100,000.00
                      && request.resource.data.amount is number
                      && request.resource.data.amount >= 0.01
                      && request.resource.data.amount <= 100000
                      // Vendor validation: 2-100 characters, non-empty
                      && request.resource.data.vendor is string
                      && request.resource.data.vendor.size() >= 2
                      && request.resource.data.vendor.size() <= 100
                      // Items validation: 1-20 items, each 1-50 characters
                      && request.resource.data.items is list
                      && request.resource.data.items.size() >= 1
                      && request.resource.data.items.size() <= 20
                      // Category validation: must be from valid list
                      && (request.resource.data.category == null 
                          || request.resource.data.category in [
                               'travel', 'meals', 'office_supplies', 'equipment',
                               'software', 'marketing', 'other'
                             ])
                      // Description: optional, max 500 characters
                      && (request.resource.data.description == null
                          || (request.resource.data.description is string
                              && request.resource.data.description.size() <= 500))
                      // Receipt URL: optional, must be valid URL if provided
                      && (request.resource.data.receiptUrl == null
                          || (request.resource.data.receiptUrl is string
                              && (request.resource.data.receiptUrl.matches('https?://.*'))))
                      // Validate individual items
                      && request.resource.data.items.hasAll([request.resource.data.items])
                      && request.resource.data.items.size() == request.resource.data.items.size();
      
      allow read: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid;
      
      allow update: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid
                     && request.resource.data.userId == request.auth.uid
                     // Prevent status updates from client (server only)
                     && (!request.resource.data.keys().hasAny(['status']) || resource.data.status == request.resource.data.status)
                     && request.resource.data.keys().hasOnly([
                          'userId', 'amount', 'vendor', 'items', 'category', 
                          'description', 'receiptUrl', 'status', 'createdAt',
                          'updatedAt', 'notes'
                        ])
                     // Re-validate fields on update
                     && request.resource.data.amount >= 0.01
                     && request.resource.data.amount <= 100000
                     && request.resource.data.vendor.size() >= 2
                     && request.resource.data.vendor.size() <= 100
                     && request.resource.data.items.size() >= 1
                     && request.resource.data.items.size() <= 20;
      
      allow delete: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid;
    }

    // Expenses subcollection for detailed line items
    match /expenses/{expenseId}/items/{itemId} {
      allow read: if isAuthenticated() 
                   && get(/databases/$(database)/documents/expenses/$(expenseId)).data.userId == request.auth.uid;
      allow write: if isAuthenticated() 
                    && get(/databases/$(database)/documents/expenses/$(expenseId)).data.userId == request.auth.uid;
    }

    // ==================== CONTACTS ====================
    // Contacts - User ownership-based access
    match /contacts/{id} {
      allow create: if isAuthenticated() 
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.name is string
                      && request.resource.data.name.size() > 0
                      && request.resource.data.phone is string
                      && hasValidPhone(request.resource.data.phone)
                      && (request.resource.data.email == null || hasValidEmail(request.resource.data.email))
                      && request.resource.data.type in ['client', 'supplier', 'other'];
      allow read: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() 
                      && resource.data.userId == request.auth.uid
                      && request.resource.data.userId == request.auth.uid
                      && (request.resource.data.email == null || hasValidEmail(request.resource.data.email))
                      && request.resource.data.keys().hasOnly([
                           'userId', 'name', 'phone', 'email', 'type', 
                           'company', 'address', 'notes', 'tags', 'lastModified'
                         ]);
      allow delete: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid;
    }

    // Contacts subcollection for interaction history
    match /contacts/{contactId}/interactions/{interactionId} {
      allow read: if isAuthenticated() 
                   && get(/databases/$(database)/documents/contacts/$(contactId)).data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
                     && get(/databases/$(database)/documents/contacts/$(contactId)).data.userId == request.auth.uid
                     && request.resource.data.date is timestamp
                     && request.resource.data.type in ['call', 'email', 'meeting', 'note'];
      allow delete: if isAuthenticated() 
                     && get(/databases/$(database)/documents/contacts/$(contactId)).data.userId == request.auth.uid;
    }

    // ==================== STOCK/INVENTORY ====================
    // Stock/Inventory - User ownership-based access
    match /stock/{id} {
      allow create: if isAuthenticated() 
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.item is string
                      && request.resource.data.item.size() > 0
                      && request.resource.data.quantity is number
                      && request.resource.data.quantity >= 0
                      && hasValidAmount(request.resource.data.cost)
                      && request.resource.data.sku is string
                      && request.resource.data.category is string;
      allow read: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() 
                      && resource.data.userId == request.auth.uid
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.quantity >= 0
                      && (request.resource.data.cost == null || request.resource.data.cost > 0)
                      && request.resource.data.keys().hasOnly([
                           'userId', 'item', 'quantity', 'cost', 'sku', 
                           'category', 'supplier', 'location', 'reorderLevel', 
                           'notes', 'lastModified'
                         ]);
      allow delete: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid;
    }

    // Stock movement history - audit trail
    match /stock/{stockId}/movements/{movementId} {
      allow read: if isAuthenticated() 
                   && get(/databases/$(database)/documents/stock/$(stockId)).data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
                     && get(/databases/$(database)/documents/stock/$(stockId)).data.userId == request.auth.uid
                     && request.resource.data.type in ['in', 'out', 'adjustment']
                     && request.resource.data.quantity is number
                     && request.resource.data.date is timestamp;
      allow delete: if false; // Audit trail is immutable
    }

    // ==================== TASKS ====================
    // Tasks - User ownership-based access
    match /tasks/{id} {
      allow create: if isAuthenticated() 
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.title is string
                      && request.resource.data.title.size() > 0
                      && request.resource.data.dueDate is timestamp
                      && request.resource.data.status in ['open', 'in_progress', 'completed', 'cancelled'];
      allow read: if isAuthenticated() 
                   && resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() 
                      && resource.data.userId == request.auth.uid
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.status in ['open', 'in_progress', 'completed', 'cancelled']
                      && request.resource.data.keys().hasOnly([
                           'userId', 'title', 'dueDate', 'status', 'description', 
                           'priority', 'assignedTo', 'completedAt', 'tags', 
                           'relatedExpenseId', 'notes', 'lastModified'
                         ]);
      allow delete: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid;
    }

    // Tasks subcollection for comments/history
    match /tasks/{taskId}/comments/{commentId} {
      allow read: if isAuthenticated() 
                   && get(/databases/$(database)/documents/tasks/$(taskId)).data.userId == request.auth.uid;
      allow create: if isAuthenticated() 
                     && get(/databases/$(database)/documents/tasks/$(taskId)).data.userId == request.auth.uid
                     && request.resource.data.text is string
                     && request.resource.data.text.size() > 0
                     && request.resource.data.userId == request.auth.uid
                     && request.resource.data.date is timestamp;
      allow delete: if isAuthenticated() 
                     && resource.data.userId == request.auth.uid;
    }

    // Mobile Modules Configuration - User-specific feature toggles
    match /mobileModules/{uid} {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if request.auth != null && request.auth.uid == uid;
    }

    // ==================== OWNER-ONLY FEATURES ====================
    // These are blocked entirely for employees

    // ==================== INVOICES ====================
    // Invoices - Owner only with data validation
    match /users/{uid}/invoices/{docId} {
      allow read: if isResourceOwner(uid) && isOwner();
      allow write: if isResourceOwner(uid) && isOwner()
                      && request.resource.data.invoiceNumber is string
                      && request.resource.data.clientId is string
                      && hasValidAmount(request.resource.data.total)
                      && request.resource.data.items is list
                      && request.resource.data.items.size() > 0
                      && request.resource.data.dueDate is timestamp
                      && request.resource.data.status in ['draft', 'sent', 'paid', 'overdue', 'cancelled'];
    }

    match /invoices/{docId} {
      allow read, write: if isOwner()
                           && resource.data.invoiceNumber is string
                           && resource.data.total is number
                           && resource.data.total > 0;
    }

    // Wallet & Billing - Owner only
    match /users/{uid}/wallet/{doc=**} {
      allow read, write: if request.auth.uid == uid && isOwner();
    }

    match /wallet/{doc=**} {
      allow read, write: if isOwner();
    }

    // Suppliers - Owner only
    match /users/{uid}/suppliers/{docId} {
      allow read, write: if request.auth.uid == uid && isOwner();
    }

    match /suppliers/{doc=**} {
      allow read, write: if isOwner();
    }

    // Purchase Orders - Owner only
    match /users/{uid}/purchaseOrders/{docId} {
      allow read, write: if request.auth.uid == uid && isOwner();
    }

    match /purchaseOrders/{doc=**} {
      allow read, write: if isOwner();
    }

    // Loyalty - Owner only
    match /users/{uid}/loyalty/{doc=**} {
      allow read: if request.auth.uid == uid && isOwner();
      allow write: if false; // Server-only
    }

    match /loyalty/{doc=**} {
      allow read, write: if isOwner();
    }

    // Inventory - Owner only
    match /users/{uid}/inventory/{docId} {
      allow read, write: if request.auth.uid == uid && isOwner();
    }

    match /inventory/{doc=**} {
      allow read, write: if isOwner();
    }

    // Settings - User can read/write own, Owner only at root
    match /users/{uid}/settings/{doc=**} {
      allow read, write: if request.auth.uid == uid;
    }

    match /settings/{doc=**} {
      allow read, write: if isOwner();
    }

    // Payment records - webhook writes only, no client access
    match /payments_processed/{sessionId} {
      allow read, write: if false; // Written only by webhook function
    }

    // fallback - restrict everything else as usual
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
