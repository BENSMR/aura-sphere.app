rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // User profile: user can read/write their own profile
    match /users/{userId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && request.auth.uid == userId;
      // allow update but disallow client changing critical fields (aura balance, roles)
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && !(request.resource.data.keys().hasAny(['wallet','roles','auraTokens','token_audit']));
      
      // Subcollections under users
      match /wallet/{doc=**} {
        // only owner can read/write their wallet docs
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      match /token_audit/{auditId} {
        // only owner or admins can read (admin logic below)
        allow read: if isOwnerOrAdmin(userId);
        // writing audit entries should be done via server (cloud functions) - deny client writes
        allow create: if false;
        allow update, delete: if false;
      }

      // Meta collection (business profile, settings)
      match /meta/{doc=**} {
        // Allow read-only access to all meta subcollections
        allow read: if request.auth != null && request.auth.uid == userId;
        // Allow write but protect invoiceCounter field (server-only)
        allow write: if request.auth != null 
                     && request.auth.uid == userId
                     && !request.resource.data.keys().hasAny(['invoiceCounter']);
      }

      // Branding collection: company colors, logos, fonts
      match /business/branding {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // Prevent user from manually editing invoiceCounter
      match /users/{userId}/meta/business {
        allow read: if request.auth.uid == userId;
        allow write: if request.auth.uid == userId
          && !("invoiceCounter" in request.resource.data);
      }

      // Generic pattern for user-owned collections (projects, invoices, crm, expenses)
      match /{subCollection}/{docId=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Invoices collection - explicit rules for clarity
      match /invoices/{invoiceId} {
        allow create: if request.auth != null && request.auth.uid == userId;
        allow read: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null 
                      && request.auth.uid == userId 
                      && request.resource.data.status in ["paid", "unpaid", "partial", "overdue", "draft", "sent", "canceled"]
                      && isValidInvoiceUpdate();
        allow delete: if request.auth != null && request.auth.uid == userId;

        // Payments subcollection: read-only for users, write-only for Stripe webhook (Cloud Functions)
        match /payments/{pid} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow write: if false; // ONLY Stripe webhook (Cloud Functions) can write
        }

        // Payment errors subcollection: read-only for users, write-only for Stripe webhook
        match /paymentErrors/{eid} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow write: if false; // ONLY Stripe webhook (Cloud Functions) can write
        }

        // PDF storage: invoice PDF metadata and URLs
        match /pdf/{pdfId} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow write: if false; // ONLY Cloud Functions (PDF generation) can write
        }
      }

      // Expenses collection with explicit rules and approval workflow
      match /expenses/{expenseId} {
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidExpenseCreate();
        allow read: if request.auth != null 
                    && (request.auth.uid == userId 
                        || isAdmin() 
                        || resource.data.approverId == request.auth.uid);
        allow update: if request.auth != null 
                      && (request.auth.uid == userId || isAdmin() || request.auth.uid == resource.data.approverId)
                      && isValidExpenseUpdate()
                      // Prevent setting taxCalculatedBy field (server-only)
                      && !(request.resource.data.keys().hasAny(['taxCalculatedBy']) 
                           && request.resource.data.taxCalculatedBy != resource.data.taxCalculatedBy);
        allow delete: if false;  // expenses are permanent for audit
        
        // Audit subcollection: immutable audit trail
        match /audit/{auditId} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow create: if request.auth != null && request.auth.uid == userId;
          allow update, delete: if false;  // audit entries are immutable
        }

        // Approvals subcollection: read-only for users, write-only for Cloud Functions
        match /approvals/{approvalId} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow write: if false; // ONLY Cloud Functions (notifyApproval trigger) can write via admin SDK
        }
      }

      // Tasks collection with specific rules
      match /tasks/{taskId} {
        allow create: if request.auth != null && request.auth.uid == userId;
        allow read: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && (request.auth.uid == userId || isAdmin());
      }

      // Invoice sequence audit trail - immutable
      match /invoice_sequence/{auditId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if false; // ONLY Cloud Functions can write
        allow update, delete: if false; // audit entries are immutable
      }

      // Invoice settings - user configuration for numbering
      match /settings/invoice_settings {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // Clients collection - user's client/customer database
      match /clients/{clientId} {
        allow create: if request.auth != null 
                      && request.auth.uid == userId
                      && request.resource.data.userId == userId
                      && isValidClientCreate();
        allow read: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null 
                      && request.auth.uid == userId
                      && isValidClientUpdate();
        allow delete: if request.auth != null && request.auth.uid == userId;
      }

      // Inventory Items collection with stock movements subcollection
      match /inventory_items/{itemId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Stock movements subcollection - audit trail for inventory changes
        match /stock_movements/{movId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }

      // Suppliers collection - user-owned supplier database
      match /suppliers/{supplierId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // Purchase Orders collection - user-owned PO database
      match /purchase_orders/{poId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
        
        // Email history stored inside PO doc
        // emailHistory is written from Cloud Functions only
        // Client can read but not directly write to emailHistory
      }

      // Stock movements collection - audit trail (writes via Cloud Functions only)
      match /stock_movements/{movId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if false; // ONLY Cloud Functions can write via admin SDK
      }

      // Analytics collection - KPIs, alerts, summaries
      match /analytics/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Email queue for Firebase Email Extension
    match /mail/{docId} {
      allow read: if false;  // nobody should read emails
      allow write: if request.auth != null;  // logged in users may send
    }

    // FX rates: allow read to authenticated users (so clients can read cached rates directly)
    match /config/fx_rates {
      allow read: if request.auth != null;
      allow write: if false; // only server scheduled function writes
    }

    // Tax matrix: allow read (tax rules read-only), write only by admins (server)
    match /config/tax_matrix/{country} {
      allow read: if request.auth != null;
      allow write: if false; // ONLY Cloud Functions can write via admin SDK
    }

    // Tax Queue System: Handles asynchronous tax calculation
    // Queue requests are created by Firestore triggers (onInvoiceCreateAutoAssign, etc.)
    // Processed by scheduled function (processTaxQueue) every 1 minute
    // Clients can read their own queue requests to monitor status
    match /internal/tax_queue/requests/{requestId} {
      // Clients cannot create queue documents directly
      // Only Firestore triggers can create them
      allow create: if false;
      
      // Clients can read their own queue requests
      // Used to check if tax calculation is pending/completed
      allow read: if request.auth != null && request.auth.uid == resource.data.uid;
      
      // Clients cannot update queue documents
      // Only Cloud Functions (processTaxQueue) can mark as processed
      allow update: if false;
      
      // Clients cannot delete queue documents
      allow delete: if false;
    }

    // Finance Module Collections: Companies and Contacts
    // Used by tax calculation system to determine tax jurisdiction and currency
    match /users/{userId}/companies/{companyId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/contacts/{contactId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // Enhanced Invoice Rules: Protect server-calculated fields
    // Users can create and read invoices, but cannot set taxCalculatedBy
    // This prevents users from spoofing tax calculations
    match /users/{userId}/invoices/{invoiceId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null 
                    && request.auth.uid == userId
                    // Prevent setting taxCalculatedBy field (server-only)
                    && !(request.resource.data.keys().hasAny(['taxCalculatedBy']) 
                         && request.resource.data.taxCalculatedBy != resource.data.taxCalculatedBy);
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // Enhanced Expense Rules: Protect server-calculated fields
    // Similar to invoices, prevent taxCalculatedBy spoofing
    match /users/{userId}/expenses/{expenseId} {
      allow create: if request.auth != null 
                    && request.auth.uid == userId
                    && isValidExpenseCreate();
      allow read: if request.auth != null 
                  && (request.auth.uid == userId 
                      || isAdmin() 
                      || resource.data.approverId == request.auth.uid);
      allow update: if request.auth != null 
                    && (request.auth.uid == userId || isAdmin() || request.auth.uid == resource.data.approverId)
                    && isValidExpenseUpdate()
                    // Prevent setting taxCalculatedBy field (server-only)
                    && !(request.resource.data.keys().hasAny(['taxCalculatedBy']) 
                         && request.resource.data.taxCalculatedBy != resource.data.taxCalculatedBy);
      allow delete: if false;  // expenses are permanent for audit
    }

    // Enhanced PurchaseOrder Rules: Protect server-calculated fields
    match /users/{userId}/purchaseOrders/{poId} {
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null 
                    && request.auth.uid == userId
                    // Prevent setting taxCalculatedBy field (server-only)
                    && !(request.resource.data.keys().hasAny(['taxCalculatedBy']) 
                         && request.resource.data.taxCalculatedBy != resource.data.taxCalculatedBy);
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // User settings
    match /users/{userId}/settings {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Admin check helper - requires a small admin collection to list admins
    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    function isOwnerOrAdmin(userId) {
      return request.auth != null && (request.auth.uid == userId || isAdmin());
    }

    // Audit ownership check
    // compositeId format: "{entityType}_{entityId}"
    // Examples: "invoice_inv-001", "wallet_user123", "expense_exp-456"
    function isAuditOwner(compositeId) {
      // Allow admins to read all audit entries
      if (isAdmin()) {
        return true;
      }
      
      // Parse compositeId: split on first underscore
      let parts = compositeId.split('_');
      if (parts.size() < 2) {
        return false;
      }
      
      let entityType = parts[0];
      let entityId = parts[1];
      
      // Entity type: invoice, expense, purchase_order, wallet, payment, company, contact
      // For user-scoped entities (invoice, expense, etc), check if user owns the entity
      if (entityType == 'invoice' || entityType == 'expense' || entityType == 'purchase_order') {
        // Check if user owns this entity in their collection
        return exists(/databases/$(database)/documents/users/$(request.auth.uid)/$(entityType)s/$(entityId));
      }
      
      if (entityType == 'wallet') {
        // Wallet entities are owned by the wallet ID (which is the userId)
        return request.auth.uid == entityId;
      }
      
      if (entityType == 'payment') {
        // Payment owned by requesting user (stored as string in compositeId)
        return request.auth.uid == entityId;
      }
      
      if (entityType == 'company' || entityType == 'contact') {
        // Check if user owns the company/contact
        return exists(/databases/$(database)/documents/users/$(request.auth.uid)/$(entityType)s/$(entityId));
      }
      
      // Default deny for unknown entity types
      return false;
    }

    // Expense validation helpers
    function isValidExpenseCreate() {
      let data = request.resource.data;
      return data.keys().hasAll(['id', 'userId', 'merchant', 'amount', 'currency', 'category', 'paymentMethod', 'photoUrls', 'vatRate'])
             && data.userId == request.auth.uid
             && data.merchant is string && data.merchant.size() > 0
             && data.amount is number && data.amount > 0
             && data.currency is string && data.currency.size() > 0
             && data.category is string && data.category.size() > 0
             && data.paymentMethod is string && data.paymentMethod.size() > 0
             && data.photoUrls is list
             && data.vatRate is number && data.vatRate >= 0
             && (data.vat == null || (data.vat is number && data.vat >= 0))
             && (data.date == null || data.date is timestamp)
             && (data.projectId == null || data.projectId is string)
             && (data.invoiceId == null || data.invoiceId is string)
             && (data.status == null || data.status is string)
             && (data.approverId == null || data.approverId is string)
             && (data.approvedNote == null || data.approvedNote is string)
             && (data.rawOcr == null || data.rawOcr is map)
             && (data.audit == null || data.audit is map)
             && data.createdAt is timestamp
             && data.size() <= 20;
    }

    function isValidExpenseUpdate() {
      let data = request.resource.data;
      let existing = resource.data;
      // Prevent userId/id/createdAt changes (immutable fields)
      return data.userId == existing.userId
             && data.id == existing.id
             && data.createdAt == existing.createdAt
             && data.merchant is string && data.merchant.size() > 0
             && data.amount is number && data.amount > 0
             && data.currency is string && data.currency.size() > 0
             && data.category is string && data.category.size() > 0
             && data.paymentMethod is string && data.paymentMethod.size() > 0
             && data.photoUrls is list
             && data.vatRate is number && data.vatRate >= 0
             && (data.vat == null || (data.vat is number && data.vat >= 0))
             && (data.date == null || data.date is timestamp)
             && (data.projectId == null || data.projectId is string)
             && (data.invoiceId == null || data.invoiceId is string)
             && (data.status == null || data.status is string)
             && (data.approverId == null || data.approverId is string)
             && (data.approvedNote == null || data.approvedNote is string)
             && (data.rawOcr == null || data.rawOcr is map)
             && (data.audit == null || data.audit is map)
             && (data.updatedAt == null || data.updatedAt is timestamp)
             && data.size() <= 20;
    }

    // Invoice validation helper - ensures payment data consistency
    function isValidInvoiceUpdate() {
      let data = request.resource.data;
      let existing = resource.data;
      // Prevent userId/id/createdAt changes (immutable fields)
      return data.userId == existing.userId
             && data.id == existing.id
             && data.createdAt == existing.createdAt
             && data.amount is number && data.amount > 0
             && data.currency is string && data.currency.size() > 0
             && data.status is string && data.status.size() > 0
             && ['draft', 'sent', 'unpaid', 'paid', 'overdue', 'partial', 'canceled'].hasAny([data.status])
             && (data.dueDate == null || data.dueDate is timestamp)
             && (data.paymentDate == null || data.paymentDate is timestamp)
             && (data.paymentMethod == null || data.paymentMethod is string)
             && (data.updatedAt == null || data.updatedAt is timestamp);
    }

    // Client validation helper - enhanced with strict field validation
    function isValidClientCreate() {
      let data = request.resource.data;
      return data.userId is string && data.userId.size() > 0 && data.userId == request.auth.uid
             && data.name is string && data.name.size() > 0 && data.name.size() <= 255
             && data.email is string && data.email.size() > 0 && isValidEmail(data.email)
             && (data.phone == null || (data.phone is string && data.phone.size() <= 20))
             && (data.company == null || (data.company is string && data.company.size() <= 255))
             && (data.address == null || (data.address is string && data.address.size() <= 500))
             && (data.country == null || (data.country is string && data.country.size() <= 100))
             && (data.notes == null || (data.notes is string && data.notes.size() <= 5000))
             && (data.tags == null || (data.tags is list && data.tags.size() <= 20))
             && (data.status == null || (data.status is string && ['active', 'inactive', 'prospect', 'churned', 'lead'].hasAny([data.status])))
             && (data.aiScore == null || (data.aiScore is number && data.aiScore >= 0 && data.aiScore <= 100))
             && (data.aiTags == null || (data.aiTags is list && data.aiTags.size() <= 20))
             && (data.aiSummary == null || (data.aiSummary is string && data.aiSummary.size() <= 5000))
             && (data.sentiment == null || (data.sentiment is string && ['positive', 'neutral', 'negative'].hasAny([data.sentiment])))
             && (data.lifetimeValue == null || (data.lifetimeValue is number && data.lifetimeValue >= 0))
             && (data.totalInvoices == null || (data.totalInvoices is number && data.totalInvoices >= 0))
             && (data.lastInvoiceAmount == null || (data.lastInvoiceAmount is number && data.lastInvoiceAmount >= 0))
             && (data.churnRisk == null || (data.churnRisk is number && data.churnRisk >= 0 && data.churnRisk <= 100))
             && (data.vipStatus == null || (data.vipStatus is bool))
             && (data.stabilityLevel == null || (data.stabilityLevel is string && ['stable', 'unstable', 'risky', 'unknown'].hasAny([data.stabilityLevel])))
             && (data.timeline == null || (data.timeline is list && isValidTimeline(data.timeline)))
             && (data.lastActivityAt == null || data.lastActivityAt is timestamp)
             && (data.lastInvoiceDate == null || data.lastInvoiceDate is timestamp)
             && (data.lastPaymentDate == null || data.lastPaymentDate is timestamp)
             && data.createdAt is timestamp
             && data.updatedAt is timestamp
             && data.size() <= 35;
    }

    function isValidClientUpdate() {
      let data = request.resource.data;
      let existing = resource.data;
      // Prevent userId/createdAt changes (immutable fields)
      return data.userId == existing.userId
             && data.createdAt == existing.createdAt
             && (data.name == null || (data.name is string && data.name.size() > 0 && data.name.size() <= 255))
             && (data.email == null || (data.email is string && isValidEmail(data.email)))
             && (data.phone == null || (data.phone is string && data.phone.size() <= 20))
             && (data.company == null || (data.company is string && data.company.size() <= 255))
             && (data.address == null || (data.address is string && data.address.size() <= 500))
             && (data.country == null || (data.country is string && data.country.size() <= 100))
             && (data.notes == null || (data.notes is string && data.notes.size() <= 5000))
             && (data.tags == null || (data.tags is list && data.tags.size() <= 20))
             && (data.status == null || (data.status is string && ['active', 'inactive', 'prospect', 'churned', 'lead'].hasAny([data.status])))
             && (data.aiScore == null || (data.aiScore is number && data.aiScore >= 0 && data.aiScore <= 100))
             && (data.aiTags == null || (data.aiTags is list && data.aiTags.size() <= 20))
             && (data.aiSummary == null || (data.aiSummary is string && data.aiSummary.size() <= 5000))
             && (data.sentiment == null || (data.sentiment is string && ['positive', 'neutral', 'negative'].hasAny([data.sentiment])))
             && (data.lifetimeValue == null || (data.lifetimeValue is number && data.lifetimeValue >= 0))
             && (data.totalInvoices == null || (data.totalInvoices is number && data.totalInvoices >= 0))
             && (data.lastInvoiceAmount == null || (data.lastInvoiceAmount is number && data.lastInvoiceAmount >= 0))
             && (data.churnRisk == null || (data.churnRisk is number && data.churnRisk >= 0 && data.churnRisk <= 100))
             && (data.vipStatus == null || (data.vipStatus is bool))
             && (data.stabilityLevel == null || (data.stabilityLevel is string && ['stable', 'unstable', 'risky', 'unknown'].hasAny([data.stabilityLevel])))
             && (data.timeline == null || (data.timeline is list && isValidTimeline(data.timeline)))
             && (data.lastActivityAt == null || data.lastActivityAt is timestamp)
             && (data.lastInvoiceDate == null || data.lastInvoiceDate is timestamp)
             && (data.lastPaymentDate == null || data.lastPaymentDate is timestamp)
             && (data.updatedAt == null || data.updatedAt is timestamp)
             && data.size() <= 35;
    }

    // Timeline validation - ensures timeline events are properly structured
    function isValidTimeline(timeline) {
      return timeline.size() <= 1000 && 
             timeline.size() > 0;
    }

    // Timeline event validation
    function isValidTimelineEvent(event) {
      return event is map
             && event.keys().hasAll(['type', 'createdAt'])
             && event.type is string 
             && ['invoice_created', 'payment_received', 'note', 'interaction', 'invoice_overdue', 'invoice_cancelled', 'invoice_refunded', 'invoice_sent', 'invoice_viewed'].hasAny([event.type])
             && event.createdAt is timestamp
             && (event.amount == null || (event.amount is number && event.amount >= 0))
             && (event.invoiceId == null || (event.invoiceId is string && event.invoiceId.size() > 0))
             && (event.message == null || (event.message is string && event.message.size() <= 500))
             && event.size() <= 10;
    }

    // Email validation helper
    function isValidEmail(email) {
      return email is string && 
             email.size() > 0 && 
             email.size() <= 255 &&
             email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    // Audit Trail Collection
    // Path: /audit/{compositeId}/entries/{entryId}
    // Format: compositeId = "{entityType}_{entityId}" (e.g., "invoice_inv-001")
    //
    // Security Model:
    // - Entity owner (e.g., invoice owner) can READ their audit entries
    // - Admins can READ all audit entries
    // - Server (Cloud Functions) can WRITE audit entries only via admin SDK
    // - Entries are IMMUTABLE (no update/delete by anyone)
    match /audit/{compositeId} {
      // Entries subcollection
      match /entries/{entryId} {
        // Allow entity owner or admin to read
        allow read: if request.auth != null && isAuditOwner(compositeId);
        
        // Cloud Functions write via admin SDK (not subject to security rules)
        // Client writes are always blocked
        allow create: if false;
        
        // Prevent updates and deletes (immutable audit trail)
        allow update, delete: if false;
      }
    }

    // Audit Index Collection (Denormalized)
    // Path: /audit_index/{compositeId}
    // Purpose: Fast lookups of latest audit entry per entity
    // Updated by: Server Cloud Functions only
    // Read by: Entity owner or admin
    match /audit_index/{compositeId} {
      allow read: if request.auth != null && isAuditOwner(compositeId);
      allow create, update: if false; // Server-only via admin SDK
      allow delete: if false;
    }

    // Top-level invoices collection - owned by userId
    match /invoices/{invoiceId} {
      allow read, write: if request.auth != null
                         && request.auth.uid == resource.data.userId;
    }

    // Internal Tax Queue (server-only)
    // Path: /internal/tax_queue/requests/{requestId}
    // Purpose: Queue for background tax calculation processing
    // Access: Admin read only, no client writes
    match /internal/tax_queue/requests/{requestId} {
      allow read: if request.auth != null && isAdmin();
      allow create, update, delete: if false; // Server-only via admin SDK
    }

    // Fallback: deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
